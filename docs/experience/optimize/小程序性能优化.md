# 小程序性能优化



## 小程序官方性能指标

- 首屏时间不超过5秒
- 渲染时间不超过500ms
- 每秒调用setData的次数不超过20次
- setData的数据在JSON.stringfy后不超过256kb
- 页面WXML节点少于1000个，节点树深度少于30层，子节点树不大于60个
- 所有网络请求都在1内返回结果



## 小程序底层架构

对于传统的网页来说，UI渲染和JS脚本是在同一个线程中进行，所以经常会出现“阻塞”行为。微信小程序基于性能的考虑，启用了双线程模型：

- 视图层：也就是webview线程，负责启用不同的webview来渲染不同的小程序页面；

- 逻辑层：一个单独的线程执行JS代码，可以控制视图层的逻辑。![06dee7fb8293b482](http://image.lanbling.com/md/06dee7fb8293b482.png)

  然而，任何线程间的数据传输都是有延时的，这意味着逻辑层和视图层间通信是异步行为。除此之外，微信为小程序提供了很多客户端原生能力，在调用客户端原生能力的过程中，微信主线程和小程序双线程之间也会发生通信，这也是一种异步行为。

  常见的几个问题：

  - 小程序启动慢
  - 白屏时间长
  - 页面渲染慢
  - 运行内存不足



## 小程序启动慢

在这个阶段，微信会完成几项工作：

1. 准备运行环境
2. 下载小程序代码包
3. 加载小程序代码包
4. 初始化小程序首页

优化策略：

1. 无用文件、函数、样式剔除

2. 减少代码包中的静态资源文件

   小程序代码包最终会经过GZIP压缩后放在CDN上，但是GZIP压缩对图片资源来说效果很低。如JPG、PNG等格式文件，本身就已经被压缩过，再用GZIP压缩有可能体积更大。建议开发者把图片、视频等静态资源都放在CDN上。

   Base64本质上是长字符串，和CDN地址比起来会更占空间。

3. 逻辑后移，精简业务代码

   不涉及前端计算的展示类逻辑，都可以适当做后移。

4. **复用模板插件**

5. 分包加载

6. 部分页面h5化

   小程序提供了web-view组件。

   小程序和h5通信可以通过JSSDK或postMessage通道来实现，详见[小程序开发文档](https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html);



## 白屏时间长

影响白屏加载时间：

- 网络资源加载时间
- 渲染时间

优化策略：

1. 启用本地缓存

   并非所有场景都适合缓存策略，譬如对数据即时性要求非常高的场景（如抢购入口）。

2. 数据预拉取

   小程序冷启动时，微信服务器代理小程序客户端发起一个HTTP请求到第三方服务器来获取数据，并且把响应数据存储在本地客户端供小程序前端调用。当小程序加载完成后，只需要调用微信提供的API wx.getBackgroundFetchData 从本地缓存获取数据即可。这种做法可以充分利用小程序启动和初始化阶段的等待时间，使更快地完成页面渲染。

   缺点：

   - 预拉取数据强缓存30分钟，对于数据实时性高的系统来说非常致命
   - 微信服务器发起的请求没有提供区分线上版本和开发版的参数，且没有提供用户IP等信息。

3. **跳转时预拉取**

4. 分包预加载

   开启了分包加载，在用户访问到包内某个页面时，小程序才会开始下载对应的分包。等待时，页面会维持“白屏”转态。

   小程序提供了分包预下载能力，开发者可以配置进入某个页面时下载可能用到的分包。

5. 非关键渲染数据延迟请求

   页面结构划分成两类：主体模块和非主体模块。

   在初始化首页时，小程序会发起一个聚合接口请求来获取主体模块的数据，而非主体模块的数据则从另一个接口获取。通过拆分的手段来降低主接口的调用时延，同时减少响应体的数据量，减少网络传输时间。

6. 分屏渲染

   接着上面的第5步骤。当小程序获取到主体模块的数据后，会优先渲染首屏模块，在所有首屏模块都渲染完成后才会想渲染非首屏模块和非主体模块，以此确保首屏内容以最快速度呈现。

7. 接口聚合，请求合并

8. 图片资源优化

   - 使用WebP格式，在肉眼无差别的图片质量前提下具有更小的图片体积

   - 图片裁剪&降质

     鉴于移动端的设备分辨率是有上限的，很多图片的尺寸常常远大于页面元素尺寸（图片尺寸2倍于页面尺寸），这非常浪费网络资源。

   - 图片懒加载、雪碧图优化

   - 降级加载图片

     先模糊后高清

     ```html
     //banner.wxml
     <image src="{{url}}"/>
     
     //图片加载器
     <image
          style="width:0;height:0;display:none;"
          src="{{preloadUrl}}"
          bindload="onImgLoad"
          binderror="onErrorLoad"
     />
     ```

     ```js
     //banner.js
     Component({
         ready(){
             this.originUrl = 'https://path/to/picture'
             this.setData({
                 url: compress(this.originUrl),
                 preloadUrl: this.originUrl
             })
         },
         methods: {
             onImgLoad(){
                 this.setData({
                     url: this.originUrl
                 });
             }
         }
     })
     ```

     

9. 骨架屏

   

## 页面渲染慢

有效的渲染方向：

- 降低线程间通信频次
- 减少线程间通信的数据量
- 减少WXML节点数量

优化策略：

1. 合并setData调用

2. 只把与界面渲染相关的数据放在data中

3. 应用层的数据diff

   在setData之前，把数据和之前的数据做对比，没有变化就不需要了。因为每一次setData都会导致data数据和WXML构建出新的节点树，和之前的节点树做比较，然后更新。

4. 去掉不必要的事件绑定

   逻辑层绑定了回调函数，就会触发通信过程。像OnPageScroll这种事件，频繁触发的，尽量避免。

5. 去掉不必要的节点属性

   节点属性越多，通信时间越长。

6. 适当的组件颗粒度

   适当的组件化可以减少数据更新时的影响范围，如倒计时组件。

7. **事件总线，代替组件间数据绑定的通信方式**

8. 组件层面的diff

   渲染时如果新的数据是旧的数据的子集，且顺序不变，则把消失的位置置位none，而不是直接setData，降低试图渲染的压力。



## 运行内存不足

优化策略：

1. 内存预警

   做埋点，做日志监测

2. 回收后台页面计时器

   一个页面一个webview线程，但js线程只有一个。当页面处于onHide状态时，可以把耗费js线程资源的操作先清理掉，例如定时器（主要是里面的代码逻辑），然后在onShow的时候再恢复。

3. 避免频发事件中重度内存操作

   对于频发事件的监听，需要遵守的原则：

   - onPageScroll事件需要节流
   - 避免CPU密集型操作，譬如复杂的计算
   - 避免调用，实在要调用要较少setData的数据量
   - 尽量使用IntersectionObserver来替代SelectorQuery，前者对性能影响更小

4. 大图、长列表优化

   对图片降质或者裁剪，当然不是最好的。

   瀑布流思路：利用intersectionObserver监听长列表内组件与视窗的相交关系，当组件距离视窗大于某个临界点时，销毁该组件释放内存，并用同等的骨架图占屏；当距离小于临界点时，再取缓存数据加载该组件。

   如果用户滑的很快，销毁后来不及加载，视觉上会出现白屏。我们可以适当调整销毁的时间点，或者优化骨架图样式来提升体验。

   小程序官方的长列表组件。

   

## 小程序生命周期

![page-lifecycle.2e646c86](http://image.lanbling.com/md/page-lifecycle.2e646c86.png)



## 原文链接

[如何打造高性能小程序门户](https://aotu.io/notes/2020/03/25/high-performance-miniprogram/)